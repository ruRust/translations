---
layout: post
title: Announcing Rust 1.78.0
author: The Rust Release Team
release: 'true'
---

Команда Rust рада сообщить о новой версии языка — 1.78.0. Rust — это язык программирования, позволяющий каждому создавать надёжное и эффективное программное обеспечение.

Если у вас есть предыдущая версия Rust, установленная через `rustup`, то для обновления до версии 1.78.0 вам достаточно выполнить команду:

```console
$ rustup update stable
```

Если у вас ещё не установлен `rustup`, вы можете установить его с [соответствующей страницы](https://www.rust-lang.org/install.html) нашего веб-сайта, а также посмотреть [подробные примечания к выпуску](https://doc.rust-lang.org/nightly/releases.html#version-1780-2024-05-02) на GitHub.

Если вы хотите помочь нам протестировать будущие выпуски, вы можете использовать канал beta (`rustup default beta`) или nightly (`rustup default nightly`). Пожалуйста, [сообщайте](https://github.com/rust-lang/rust/issues/new/choose) обо всех встреченных вами ошибках.

## Что стабилизировано в 1.78.0

### Diagnostic attributes

Rust now supports a `#[diagnostic]` attribute namespace to influence compiler error messages. These are treated as hints which the compiler is not *required* to use, and it is also not an error to provide a diagnostic that the compiler doesn't recognize. This flexibility allows source code to provide diagnostics even when they're not supported by all compilers, whether those are different versions or entirely different implementations.

With this namespace comes the first supported attribute, `#[diagnostic::on_unimplemented]`, which can be placed on a trait to customize the message when that trait is required but hasn't been implemented on a type. Consider the example given in the [stabilization pull request](https://github.com/rust-lang/rust/pull/119888/):

```rust
#[diagnostic::on_unimplemented(
    message = "My Message for `ImportantTrait<{A}>` is not implemented for `{Self}`",
    label = "My Label",
    note = "Note 1",
    note = "Note 2"
)]
trait ImportantTrait<A> {}

fn use_my_trait(_: impl ImportantTrait<i32>) {}

fn main() {
    use_my_trait(String::new());
}
```

Previously, the compiler would give a builtin error like this:

```
error[E0277]: the trait bound `String: ImportantTrait<i32>` is not satisfied
  --> src/main.rs:12:18
   |
12 |     use_my_trait(String::new());
   |     ------------ ^^^^^^^^^^^^^ the trait `ImportantTrait<i32>` is not implemented for `String`
   |     |
   |     required by a bound introduced by this call
   |
```

With `#[diagnostic::on_unimplemented]`, its custom message fills the primary error line, and its custom label is placed on the source output. The original label is still written as help output, and any custom notes are written as well. (These exact details are subject to change.)

```
error[E0277]: My Message for `ImportantTrait<i32>` is not implemented for `String`
  --> src/main.rs:12:18
   |
12 |     use_my_trait(String::new());
   |     ------------ ^^^^^^^^^^^^^ My Label
   |     |
   |     required by a bound introduced by this call
   |
   = help: the trait `ImportantTrait<i32>` is not implemented for `String`
   = note: Note 1
   = note: Note 2
```

For trait authors, this kind of diagnostic is more useful if you can provide a better hint than just talking about the missing implementation itself. For example, this is an abridged sample from the standard library:

```rust
#[diagnostic::on_unimplemented(
    message = "the size for values of type `{Self}` cannot be known at compilation time",
    label = "doesn't have a size known at compile-time"
)]
pub trait Sized {}
```

For more information, see the reference section on [the `diagnostic` tool attribute namespace](https://doc.rust-lang.org/stable/reference/attributes/diagnostics.html#the-diagnostic-tool-attribute-namespace).

### Проверка предусловий `unsafe`

The Rust standard library has a number of assertions for the preconditions of `unsafe` functions, but historically they have only been enabled in `#[cfg(debug_assertions)]` builds of the standard library to avoid affecting release performance. However, since the standard library is usually compiled and distributed in release mode, most Rust developers weren't ever executing these checks at all.

Теперь выполнение условий для этих проверок откладывается до генерации кода, поэтому они будут проверяться в зависимости от собственных настроек пользователя для отладочных проверок, включенных по умолчанию в отладочных и тестовых сборках. Это изменение помогает пользователям отслеживать неопределённое поведение в своём коде, хотя информация о том, сколько всего проверяется, как правило, не является стабильной.

Например [`slice::from_raw_parts`](https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html) требует выровненный ненулевой указатель. Следующее использование намеренно смещенного указателя приводит к неопределенному поведению, и хотя это может не иметь очевидных последствий, debug-проверка теперь может перехватить его:

```rust
fn main() {
    let slice: &[u8] = &[1, 2, 3, 4, 5];
    let ptr = slice.as_ptr();

    // Создание отступа от `ptr` что всегда будет единственным отличием от корректного смещения `u16`
    let i = usize::from(ptr as usize & 1 == 0);
    
    let slice16: &[u16] = unsafe { std::slice::from_raw_parts(ptr.add(i).cast::<u16>(), 2) };
    dbg!(slice16);
}
```

```
thread 'main' panicked at library/core/src/panicking.rs:220:5:
unsafe precondition(s) violated: slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
thread caused non-unwinding panic. aborting.
```

### Deterministic realignment

The standard library has a few functions that change the alignment of pointers and slices, but they previously had caveats that made them difficult to rely on in practice, if you followed their documentation precisely. Those caveats primarily existed as a hedge against `const` evaluation, but they're only stable for non-`const` use anyway. They are now promised to have consistent runtime behavior according to their actual inputs.

- [`pointer::align_offset`](https://doc.rust-lang.org/std/primitive.pointer.html#method.align_offset) computes the offset needed to change a pointer to the given alignment. It returns `usize::MAX` if that is not possible, but it was previously permitted to *always* return `usize::MAX`, and now that behavior is removed.

- [`slice::align_to`](https://doc.rust-lang.org/std/primitive.slice.html#method.align_to) and [`slice::align_to_mut`](https://doc.rust-lang.org/std/primitive.slice.html#method.align_to_mut) both transmute slices to an aligned middle slice and the remaining unaligned head and tail slices. These methods now promise to return the largest possible middle part, rather than allowing the implementation to return something less optimal like returning everything as the head slice.

### Стабилизированные API

- [`impl Read for &Stdin`](https://doc.rust-lang.org/stable/std/io/struct.Stdin.html#impl-Read-for-%26Stdin)
- [В зависимости от реализации разрешены не `'static` времена жизни для некоторых `std::error::Error`](https://github.com/rust-lang/rust/pull/113833/)
- [`impl<Fd: AsFd>` имплементирует `?Sized`](https://github.com/rust-lang/rust/pull/114655/)
- [`impl From<TryReserveError> for io::Error`](https://doc.rust-lang.org/stable/std/io/struct.Error.html#impl-From%3CTryReserveError%3E-for-Error)

Следующие API теперь можно использовать в контексте <code>const</code>:

- [`Barrier::new()`](https://doc.rust-lang.org/stable/std/sync/struct.Barrier.html#method.new)

### Замечания о совместимости

- Как [ранее анонсировалось](https://blog.rust-lang.org/2024/02/26/Windows-7.html), в Rust 1.78 поднимается минимальное требование до Windows 10 для следующих целевых платформ:
    - `x86_64-pc-windows-msvc`
    - `i686-pc-windows-msvc`
    - `x86_64-pc-windows-gnu`
    - `i686-pc-windows-gnu`
    - `x86_64-pc-windows-gnullvm`
    - `i686-pc-windows-gnullvm`
- Rust 1.78 has upgraded its bundled LLVM to version 18, completing the announced [`u128`/`i128` ABI change](https://blog.rust-lang.org/2024/03/30/i128-layout-update.html) for x86-32 and x86-64 targets. Distributors that use their own LLVM older than 18 may still face the calling convention bugs mentioned in that post.

### Прочие изменения

Проверьте всё, что изменилось в [Rust](https://github.com/rust-lang/rust/releases/tag/1.78.0), [Cargo](https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-178-2024-05-02) и [Clippy](https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-178).

## Кто работал над 1.78.0

Многие люди собрались вместе, чтобы создать Rust 1.78.0. Без вас мы бы не справились. [Спасибо!](https://thanks.rust-lang.org/rust/1.78.0/)
