---
layout: post
title: Announcing Rust 1.64.0
author: The Rust Release Team
release: 'true'
---

Команда Rust рада сообщить о новой версии языка — 1.64.0. Rust — это язык программирования, позволяющий каждому создавать надёжное и эффективное программное обеспечение.

Если у вас есть предыдущая версия Rust, установленная через `rustup`, то для обновления до версии 1.64.0 вам достаточно выполнить команду:

```console
rustup update stable
```

Если у вас ещё нет `rustup`, то можете установить его со [страницы](https://www.rust-lang.org/install.html) на нашем веб-сайте, а также ознакомиться с [подробным описанием выпуска 1.64.0](https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1640-2022-09-22) на GitHub.

Если вы хотите помочь нам протестировать будущие выпуски, вы можете использовать beta (`rustup default beta`) или nightly (`rustup default nightly`) канал. Пожалуйста, [сообщайте](https://github.com/rust-lang/rust/issues/new/choose) обо всех встреченных вами ошибках.

## Что стабилизировано в 1.64.0

### Улучшение `.await` с помощью `IntoFuture`

Rust 1.64 stabilizes the [`IntoFuture`](https://doc.rust-lang.org/std/future/trait.IntoFuture.html) trait. `IntoFuture` is a trait similar to [`IntoIterator`](https://doc.rust-lang.org/std/iter/trait.IntoIterator.html), but rather than supporting `for ... in ...` loops, `IntoFuture` changes how `.await` works. With `IntoFuture`, the `.await` keyword can await more than just futures; it can await <em data-md-type="emphasis">anything which can be converted into a <code data-md-type="codespan">Future</code> via `IntoFuture`</em> - which can help make your APIs more user-friendly!

Take for example a builder which constructs requests to some storage provider over the network:

```rust
pub struct Error { ... }
pub struct StorageResponse { ... }:
pub struct StorageRequest(bool);

impl StorageRequest {
    /// Create a new instance of `StorageRequest`.
    pub fn new() -> Self { ... }
    /// Decide whether debug mode should be enabled.
    pub fn set_debug(self, b: bool) -> Self { ... }
    /// Send the request and receive a response.
    pub async fn send(self) -> Result<StorageResponse, Error> { ... }
}
```

Typical usage would likely look something like this:

```rust
let response = StorageRequest::new()  // 1. create a new instance
    .set_debug(true)                  // 2. set some option
    .send()                           // 3. construct the future
    .await?;                          // 4. run the future + propagate errors
```

This is not bad, but we can do better here. Using `IntoFuture` we can combine *"construct the future"* (line 3) and *"run the future"* (line 4) into a single step:

```rust
let response = StorageRequest::new()  // 1. create a new instance
    .set_debug(true)                  // 2. set some option
    .await?;                          // 3. construct + run the future + propagate errors
```

We can do this by implementing `IntoFuture` for `StorageRequest`. `IntoFuture` requires us to have a named future we can return, which we can do by creating a "boxed future" and defining a type alias for it:

```rust
// First we must import some new types into the scope.
use std::pin::Pin;
use std::future::{Future, IntoFuture};

pub struct Error { ... }
pub struct StorageResponse { ... }
pub struct StorageRequest(bool);

impl StorageRequest {
    /// Create a new instance of `StorageRequest`.
    pub fn new() -> Self { ... }
    /// Decide whether debug mode should be enabled.
    pub fn set_debug(self, b: bool) -> Self { ... }
    /// Send the request and receive a response.
    pub async fn send(self) -> Result<StorageResponse, Error> { ... }
}

// The new implementations:
// 1. create a new named future type
// 2. implement `IntoFuture` for `StorageRequest`
pub type StorageRequestFuture = Pin<Box<dyn Future<Output = Result<StorageResponse, Error> + Send + 'static>>
impl IntoFuture for StorageRequest {
    type IntoFuture = StorageRequestFuture;
    type Output = <StorageRequestFuture as Future>::Output;
    fn into_future(self) -> Self::IntoFuture {
        Box::pin(self.send())
    }
}
```

Это требует немного больше кода для реализации, но предоставляет более простой API для пользователей.

In the future, the Rust Async WG hopes to simplify the creating new named futures by supporting [`impl Trait` in `type` aliases (Type Alias Impl Trait or TAIT)](https://rust-lang.github.io/impl-trait-initiative/explainer/tait.html). This should make implementing `IntoFuture` easier by simplifying the type alias' signature, and make it more performant by removing the `Box` from the type alias.

### C-совместимые типы FFI в core и alloc

When calling or being called by C ABIs, Rust code can use type aliases like `c_uint` or `c_ulong` to match the corresponding types from C on any target, without requiring target-specific code or conditionals.

Раньше эти псевдонимы типов были доступны только в `std`, поэтому код, написанный для встроенных систем и других сценариев, которые могли использовать только `core` или `alloc`, не мог использовать эти типы.

Rust 1.64 now provides all of the `c_*` type aliases in [`core::ffi`](https://doc.rust-lang.org/core/ffi/index.html), as well as [`core::ffi::CStr`](https://doc.rust-lang.org/core/ffi/struct.CStr.html) for working with C strings. Rust 1.64 also provides [`alloc::ffi::CString`](https://doc.rust-lang.org/alloc/ffi/struct.CString.html) for working with owned C strings using only the `alloc` crate, rather than the full `std` library.

### rust-analyzer is now available via rustup

[rust-analyzer](https://rust-analyzer.github.io/) is now included as part of the collection of tools included with Rust. This makes it easier to download and access rust-analyzer, and makes it available on more platforms. It is available as a [rustup component](https://rust-lang.github.io/rustup/concepts/components.html) which can be installed with:

```
rustup component add rust-analyzer
```

В настоящее время, чтобы запустить версию, установленную rustup, вам нужно вызвать её следующим образом:

```
rustup run stable rust-analyzer
```

The next release of rustup will provide a built-in proxy so that running the executable `rust-analyzer` will launch the appropriate version.

Большинству пользователей следует продолжать использовать выпуски, предоставленные командой rust-analyzer (доступны на [странице выпусков rust-analyzer](https://github.com/rust-lang/rust-analyzer/releases)), которые публикуются чаще. Это не затрагивает пользователей [официального расширения VSCode](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer), поскольку оно автоматически загружает и обновляет выпуски в фоновом режиме.

### Улучшения Cargo: наследование рабочей области и многоцелевые сборки

When working with collections of related libraries or binary crates in one Cargo workspace, you can now avoid duplication of common field values between crates, such as common version numbers, repository URLs, or `rust-version`. This also helps keep these values in sync between crates when updating them. For more details, see [`workspace.package`](https://doc.rust-lang.org/cargo/reference/workspaces.html#the-package-table), [`workspace.dependencies`](https://doc.rust-lang.org/cargo/reference/workspaces.html#the-dependencies-table), and ["inheriting a dependency from a workspace"](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#inheriting-a-dependency-from-a-workspace).

When building for multiple targets, you can now pass multiple `--target` options to `cargo build`, to build all of those targets at once. You can also set [`build.target`](https://doc.rust-lang.org/cargo/reference/config.html#buildtarget) to an array of multiple targets in `.cargo/config.toml` to build for multiple targets by default.

### Стабилизированные API

Стабилизированы следующие методы и реализации трейтов:

- [`future::IntoFuture`](https://doc.rust-lang.org/stable/std/future/trait.IntoFuture.html)
- [`num::NonZero*::checked_mul`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_mul)
- [`num::NonZero*::checked_pow`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_pow)
- [`num::NonZero*::saturating_mul`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.saturating_mul)
- [`num::NonZero*::saturating_pow`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.saturating_pow)
- [`num::NonZeroI*::abs`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.abs)
- [`num::NonZeroI*::checked_abs`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.checked_abs)
- [`num::NonZeroI*::overflowing_abs`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.overflowing_abs)
- [`num::NonZeroI*::saturating_abs`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.saturating_abs)
- [`num::NonZeroI*::unsigned_abs`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.unsigned_abs)
- [`num::NonZeroI*::wrapping_abs`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.wrapping_abs)
- [`num::NonZeroU*::checked_add`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_add)
- [`num::NonZeroU*::checked_next_power_of_two`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_next_power_of_two)
- [`num::NonZeroU*::saturating_add`](https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.saturating_add)
- [`os::unix::process::CommandExt::process_group`](https://doc.rust-lang.org/stable/std/os/unix/process/trait.CommandExt.html#tymethod.process_group)
- [`os::windows::fs::FileTypeExt::is_symlink_dir`](https://doc.rust-lang.org/stable/std/os/windows/fs/trait.FileTypeExt.html#tymethod.is_symlink_dir)
- [`os::windows::fs::FileTypeExt::is_symlink_file`](https://doc.rust-lang.org/stable/std/os/windows/fs/trait.FileTypeExt.html#tymethod.is_symlink_file)

These types were previously stable in `std::ffi`, but are now also available in `core` and `alloc`:

- [`core::ffi::CStr`](https://doc.rust-lang.org/stable/core/ffi/struct.CStr.html)
- [`core::ffi::FromBytesWithNulError`](https://doc.rust-lang.org/stable/core/ffi/struct.FromBytesWithNulError.html)
- [`alloc::ffi::CString`](https://doc.rust-lang.org/stable/alloc/ffi/struct.CString.html)
- [`alloc::ffi::FromVecWithNulError`](https://doc.rust-lang.org/stable/alloc/ffi/struct.FromVecWithNulError.html)
- [`alloc::ffi::IntoStringError`](https://doc.rust-lang.org/stable/alloc/ffi/struct.IntoStringError.html)
- [`alloc::ffi::NulError`](https://doc.rust-lang.org/stable/alloc/ffi/struct.NulError.html)

These types were previously stable in `std::os::raw`, but are now also available in `core::ffi` and `std::ffi`:

- [`ffi::c_char`](https://doc.rust-lang.org/stable/std/ffi/type.c_char.html)
- [`ffi::c_double`](https://doc.rust-lang.org/stable/std/ffi/type.c_double.html)
- [`ffi::c_float`](https://doc.rust-lang.org/stable/std/ffi/type.c_float.html)
- [`ffi::c_int`](https://doc.rust-lang.org/stable/std/ffi/type.c_int.html)
- [`ffi::c_long`](https://doc.rust-lang.org/stable/std/ffi/type.c_long.html)
- [`ffi::c_longlong`](https://doc.rust-lang.org/stable/std/ffi/type.c_longlong.html)
- [`ffi::c_schar`](https://doc.rust-lang.org/stable/std/ffi/type.c_schar.html)
- [`ffi::c_short`](https://doc.rust-lang.org/stable/std/ffi/type.c_short.html)
- [`ffi::c_uchar`](https://doc.rust-lang.org/stable/std/ffi/type.c_uchar.html)
- [`ffi::c_uint`](https://doc.rust-lang.org/stable/std/ffi/type.c_uint.html)
- [`ffi::c_ulong`](https://doc.rust-lang.org/stable/std/ffi/type.c_ulong.html)
- [`ffi::c_ulonglong`](https://doc.rust-lang.org/stable/std/ffi/type.c_ulonglong.html)
- [`ffi::c_ushort`](https://doc.rust-lang.org/stable/std/ffi/type.c_ushort.html)

We've stabilized some helpers for use with `Poll`, the low-level implementation underneath futures:

- [`future::poll_fn`](https://doc.rust-lang.org/stable/std/future/fn.poll_fn.html)
- [`task::ready!`](https://doc.rust-lang.org/stable/std/task/macro.ready.html)

In the future, we hope to provide simpler APIs that require less use of low-level details like `Poll` and `Pin`, but in the meantime, these helpers make it easier to write such code.

These APIs are now usable in const contexts:

- [`slice::from_raw_parts`](https://doc.rust-lang.org/stable/core/slice/fn.from_raw_parts.html)

### Замечания о совместимости

- As [previously announced](https://blog.rust-lang.org/2022/08/01/Increasing-glibc-kernel-requirements.html), `linux` targets now require at least Linux kernel 3.2 (except for targets which already required a newer kernel), and `linux-gnu` targets now require glibc 2.17 (except for targets which already required a newer glibc).

- Rust 1.64.0 changes the memory layout of `Ipv4Addr`, `Ipv6Addr`, `SocketAddrV4` and `SocketAddrV6` to be more compact and memory efficient. This internal representation was never exposed, but some crates relied on it anyway by using `std::mem::transmute`, resulting in invalid memory accesses. Such internal implementation details of the standard library are *never* considered a stable interface. To limit the damage, we worked with the authors of all of the still-maintained crates doing so to release fixed versions, which have been out for more than a year. The vast majority of impacted users should be able to mitigate with a `cargo update`.

- В рамках [прекращения поддержки RLS](https://blog.rust-lang.org/2022/07/01/RLS-deprecation.html) это также последний выпуск, содержащий копию RLS. Начиная с Rust 1.65.0, RLS будет заменён небольшим сервером LSP, показывающим предупреждение об устаревании.

### Прочие изменения

Выпуск Rust 1.64 включает и другие изменения:

- Компилятор Rust для Windows теперь собирается с PGO, что даёт прирост производительности при компилировании кода на 10-20%.

- If you define a struct containing fields that are never used, rustc will warn about the unused fields. Now, in Rust 1.64, you can enable the `unused_tuple_struct_fields` lint to get the same warnings about unused fields in a tuple struct. In future versions, we plan to make this lint warn by default.  Fields of type unit (`()`) do not produce this warning, to make it easier to migrate existing code without having to change tuple indices.

Проверьте всё, что изменилось в [Rust](https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1640-2022-09-22), [Cargo](https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-164-2022-09-22) и [Clippy](https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-164).

### Участники 1.64.0

Многие люди собрались вместе, чтобы создать Rust 1.64.0. Без вас мы бы не справились. [Спасибо!](https://thanks.rust-lang.org/rust/1.64.0/)
