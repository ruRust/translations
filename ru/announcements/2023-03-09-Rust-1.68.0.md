---
layout: post
title: 'Rust 1.68.0: разреженный протокол cargo, локальный pin, обработчик ошибок аллокации'
author: The Rust Release Team
release: 'true'
---

Команда Rust рада сообщить о новой версии языка — 1.68.0. Rust — это язык программирования, позволяющий каждому создавать надёжное и эффективное программное обеспечение.

Если у вас есть предыдущая версия Rust, установленная через `rustup`, то для обновления до версии 1.68.0 вам достаточно выполнить команду:

```console
rustup update stable
```

Если у вас ещё не установлен `rustup`, вы можете установить его с [соответствующей страницы](https://www.rust-lang.org/install.html) нашего веб-сайта, а также посмотреть [подробные примечания к выпуску](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1680-2023-03-09) на GitHub.

Если вы хотите помочь нам протестировать будущие выпуски, вы можете использовать beta (`rustup default beta`) или nightly (`rustup default nightly`) канал. Пожалуйста, [сообщайте](https://github.com/rust-lang/rust/issues/new/choose) обо всех встреченных вами ошибках.

## Что стабилизировано в 1.68.0

### Разреженный протокол cargo

Cargo's "sparse" registry protocol has been stabilized for reading the index of crates, along with infrastructure at `https://index.crates.io/` for those published in the primary crates.io registry. The prior git protocol (which is still the default) clones a repository that indexes *all* crates available in the registry, but this has started to hit scaling limitations, with noticeable delays while updating that repository. The new protocol should provide a significant performance improvement when accessing crates.io, as it will only download information about the subset of crates that you actually use.

Для использования разреженного протокола crates.io установите переменную окружения `CARGO_REGISTRIES_CRATES_IO_PROTOCOL=sparse` или добавьте в [`.cargo/config.toml`](https://doc.rust-lang.org/cargo/reference/config.html):

```toml
[registries.crates-io]
protocol = "sparse"
```

The sparse protocol is currently planned to become the default for crates.io in the 1.70.0 release in a few months. For more information, please see the prior [announcement](https://blog.rust-lang.org/inside-rust/2023/01/30/cargo-sparse-protocol.html) on the Inside Rust Blog, as well as [RFC 2789](https://rust-lang.github.io/rfcs/2789-sparse-index.html) and the current [documentation](https://doc.rust-lang.org/stable/cargo/reference/registry-index.html#sparse-protocol) in the Cargo Book.

### Локальное создание `Pin`

The new [`pin!`](https://doc.rust-lang.org/stable/std/pin/macro.pin.html) macro constructs a `Pin<&mut T>` from a `T` expression, anonymously captured in local state. This is often called stack-pinning, but that "stack" could also be the captured state of an `async fn` or block. This macro is similar to some crates, like [`tokio::pin!`](https://docs.rs/tokio/1/tokio/macro.pin.html), but the standard library can take advantage of `Pin` internals and [temporary lifetime extension](https://doc.rust-lang.org/stable/reference/destructors.html#temporary-lifetime-extension) for a more expression-like macro.

```rust
/// Полностью выполняет футуру.
fn block_on<F: Future>(future: F) -> F::Output {
    let waker_that_unparks_thread = todo!();
    let mut cx = Context::from_waker(&waker_that_unparks_thread);
    // Футура запинена, так что она может быть опрошена.
    let mut pinned_future = pin!(future);
    loop {
        match pinned_future.as_mut().poll(&mut cx) {
            Poll::Pending => thread::park(),
            Poll::Ready(result) => return result,
        }
    }
}
```

In this example, the original `future` will be moved into a temporary local, referenced by the new `pinned_future` with type `Pin<&mut F>`, and that pin is subject to the normal borrow checker to make sure it can't outlive that local.

### Обработчик ошибок `alloc` по умолчанию

When allocation fails in Rust, APIs like `Box::new` and `Vec::push` have no way to indicate that failure, so some divergent execution path needs to be taken. When using the `std` crate, the program will print to `stderr` and abort. As of Rust 1.68.0, binaries which include `std` will continue to have this behavior. Binaries which do not include `std`, only including `alloc`, will now `panic!` on allocation failure, which may be further adjusted via a `#[panic_handler]` if desired.

In the future, it's likely that the behavior for `std` will also be changed to match that of `alloc`-only binaries.

### Стабилизированные API

- [`{core,std}::pin::pin!`](https://doc.rust-lang.org/stable/std/pin/macro.pin.html)
- [`impl From<bool> for {f32,f64}`](https://doc.rust-lang.org/stable/std/primitive.f32.html#impl-From%3Cbool%3E-for-f32)
- [`std::path::MAIN_SEPARATOR_STR`](https://doc.rust-lang.org/stable/std/path/constant.MAIN_SEPARATOR_STR.html)
- [`impl DerefMut for PathBuf`](https://doc.rust-lang.org/stable/std/path/struct.PathBuf.html#impl-DerefMut-for-PathBuf)

Следующие API теперь возможно использовать в контексте `const`:

- [`VecDeque::new`](https://doc.rust-lang.org/stable/std/collections/struct.VecDeque.html#method.new)

### Прочие изменения

- Как [ранее сообщалось](https://blog.rust-lang.org/2023/01/09/android-ndk-update-r25.html), целевой платформой для Android теперь является NDK r25, которая соответствует минимально поддерживаемому уровню API 19 (KitKat).

Проверьте всё, что изменилось в [Rust](https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1680-2023-03-09), [Cargo](https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-168-2023-03-09) и [Clippy](https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-168).

### Участники 1.68.0

Многие люди собрались вместе, чтобы создать Rust 1.68.0. Без вас мы бы не справились. [Спасибо!](https://thanks.rust-lang.org/rust/1.68.0/)
