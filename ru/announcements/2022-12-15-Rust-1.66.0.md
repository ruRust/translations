---
layout: post
title: 'Rust 1.66.0: дискриминанты для перечислений с полями, black_box, cargo remove'
author: The Rust Release Team
release: 'true'
---

Команда Rust рада сообщить о новой версии языка — 1.66.0. Rust — это язык программирования, позволяющий каждому создавать надёжное и эффективное программное обеспечение.

Если у вас есть предыдущая версия Rust, установленная через `rustup`, то для обновления до версии 1.66.0 вам достаточно выполнить команду:

```console
rustup update stable
```

Если у вас ещё нет `rustup`, то можете установить его со [страницы](https://www.rust-lang.org/install.html) на нашем веб-сайте, а также ознакомиться с [подробным описанием выпуска 1.66.0](https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1660-2022-12-15) на GitHub.

Если вы хотите помочь нам протестировать будущие выпуски, вы можете использовать beta (`rustup default beta`) или nightly (`rustup default nightly`) канал. Пожалуйста, [сообщайте](https://github.com/rust-lang/rust/issues/new/choose) обо всех встреченных вами ошибках.

## Что стабилизировано в 1.66.0

### Явные дискриминанты для перечислений с полями

Перечисления с числовым представлением теперь могут использовать явный дискриминант, даже если они имеют поля.

```rust
#[repr(u8)]
enum Foo {
    A(u8),
    B(i8),
    C(bool) = 42,
}
```

Ранее вы могли использовать явные дискриминанты в перечислениях, но только ни один из вариантов не содержал полня. Явные дискриминанты полезны при передаче значения между разными языкам и значение перечисления нужно определить в обоих языках. Например:

```rust
#[repr(u8)]
enum Bar {
    A,
    B,
    C = 42,
    D,
}
```

Here the `Bar` enum is guaranteed to have the same layout as `u8`. In addition, the `Bar::C` variant is guaranteed to have a discriminant of 42. Variants without explicitly-specified values will have discriminants that are automatically assigned according to their order in the source code, so `Bar::A` will have a discriminant of 0, `Bar::B` will have a discriminant of 1, and `Bar::D` will have a discriminant of 43. Without this feature, the only way to set the explicit value of `Bar::C` would be to add 41 unnecessary variants before it!

Note: whereas for field-less enums it is possible to inspect a discriminant via `as` casting (e.g. `Bar::C as u8`), Rust provides no language-level way to access the raw discriminant of an enum with fields. Instead, currently unsafe code must be used to inspect the discriminant of an enum with fields. Since this feature is intended for use with cross-language FFI where unsafe code is already necessary, this should hopefully not be too much of an extra burden. In the meantime, if all you need is an opaque handle to the discriminant, please see the `std::mem::discriminant` function.

### `core::hint::black_box`

Когда исследуется или оценивается машинный код, сгенерированный компилятором, бывает полезно отключить оптимизацию для определённых мест. В следующем примере функция `push_cap` 4 раза вызывает в цикле `Vec::push`:

```rust
fn push_cap(v: &mut Vec<i32>) {
    for i in 0..4 {
        v.push(i);
    }
}

pub fn bench_push() -> Duration {
    let mut v = Vec::with_capacity(4);
    let now = Instant::now();
    push_cap(&mut v);
    now.elapsed()
}
```

Если вы посмотрите оптимизированный вывод компилятора для x86_64, вы заметите, что он выглядит достаточно коротко:

```asm
example::bench_push:
  sub rsp, 24
  call qword ptr [rip + std::time::Instant::now@GOTPCREL]
  lea rdi, [rsp + 8]
  mov qword ptr [rsp + 8], rax
  mov dword ptr [rsp + 16], edx
  call qword ptr [rip + std::time::Instant::elapsed@GOTPCREL]
  add rsp, 24
  ret
```

Фактически, вся функция `push_cap`, которую мы хотели оценить, была оптимизирована!

Мы можем обойти это при помощи новой стабилизированной функции `black_box`. Функционально `black_box` не очень интересна: она лишь берёт значение, которое вы ей передали, и возвращает его обратно. Однако внутри компилятор обрабатывает `black_box` как функцию, которая что-то делает с передаваемым ей вводом и возвращает какое-то значение (как и следует из её названия).

Это очень полезно для отключение оптимизаций, как той, что мы видели выше. Например, мы можем подсказать компилятору, что вектор будет использоваться для чего-то после каждой итерации цикла.

```rust
use std::hint::black_box;

fn push_cap(v: &mut Vec<i32>) {
    for i in 0..4 {
        v.push(i);
        black_box(v.as_ptr());
    }
}
```

Now we can find the unrolled for loop in our [optimized assembly output](https://rust.godbolt.org/z/Ws1GGbY6Y):

```asm
  mov dword ptr [rbx], 0
  mov qword ptr [rsp + 8], rbx
  mov dword ptr [rbx + 4], 1
  mov qword ptr [rsp + 8], rbx
  mov dword ptr [rbx + 8], 2
  mov qword ptr [rsp + 8], rbx
  mov dword ptr [rbx + 12], 3
  mov qword ptr [rsp + 8], rbx
```

You can also see a side effect of calling `black_box` in this assembly output. The instruction `mov qword ptr [rsp + 8], rbx` is uselessly repeated after every iteration. This instruction writes the address `v.as_ptr()` as the first argument of the function, which is never actually called.

Notice that the generated code is not at all concerned with the possibility of allocations introduced by the `push` call. This is because the compiler is still using the fact that we called `Vec::with_capacity(4)` in the `bench_push` function. You can play around with the placement of `black_box`, or try using it in multiple places, to see its effects on compiler optimizations.

### cargo remove

Rust 1.62.0 представил `cargo add` - утилиту командной строки для добавления зависимостей в ваш проект. Теперь же вы можете использовать `cargo remove` для удаления зависимостей.

### Стабилизированные API

- [`proc_macro::Span::source_text`](https://doc.rust-lang.org/stable/proc_macro/struct.Span.html#method.source_text)
- [`u*::{checked_add_signed, overflowing_add_signed, saturating_add_signed, wrapping_add_signed}`](https://doc.rust-lang.org/stable/std/primitive.u8.html#method.checked_add_signed)
- [`i*::{checked_add_unsigned, overflowing_add_unsigned, saturating_add_unsigned, wrapping_add_unsigned}`](https://doc.rust-lang.org/stable/std/primitive.i8.html#method.checked_add_unsigned)
- [`i*::{checked_sub_unsigned, overflowing_sub_unsigned, saturating_sub_unsigned, wrapping_sub_unsigned}`](https://doc.rust-lang.org/stable/std/primitive.i8.html#method.checked_sub_unsigned)
- [`BTreeSet::{first, last, pop_first, pop_last}`](https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html#method.first)
- [`BTreeMap::{first_key_value, last_key_value, first_entry, last_entry, pop_first, pop_last}`](https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html#method.first_key_value)
- [Добавлена реализация `AsFd` для типов блокировок стандартных потоков для WASI.](https://github.com/rust-lang/rust/pull/101768/)
- [`impl TryFrom<Vec<T>> for Box<[T; N]>`](https://doc.rust-lang.org/stable/std/boxed/struct.Box.html#impl-TryFrom%3CVec%3CT%2C%20Global%3E%3E-for-Box%3C%5BT%3B%20N%5D%2C%20Global%3E)
- [`core::hint::black_box`](https://doc.rust-lang.org/stable/std/hint/fn.black_box.html)
- [`Duration::try_from_secs_{f32,f64}`](https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.try_from_secs_f32)
- [`Option::unzip`](https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.unzip)
- [`std::os::fd`](https://doc.rust-lang.org/stable/std/os/fd/index.html)

### Прочие изменения

Выпуск Rust 1.66 включает и другие изменения:

- Теперь вы можете использовать в шаблонах диапазоны <code>..=X</code>.
- Linux-сборки теперь используют оптимизированные rustc фронтенд и LLVM бекенд с LTO и BOLT соответственно, что оптимизирует быстродействие и использование памяти.

Проверьте всё, что изменилось в [Rust](https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1660-2022-12-15), [Cargo](https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-166-2022-12-15) и [Clippy](https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-166).

### Участники 1.66.0

Многие люди собрались вместе, чтобы создать Rust 1.66.0. Без вас мы бы не справились. [Спасибо!](https://thanks.rust-lang.org/rust/1.66.0/)
