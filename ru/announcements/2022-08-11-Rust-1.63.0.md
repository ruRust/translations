---
layout: post
title: Announcing Rust 1.63.0
author: The Rust Release Team
release: 'true'
---

Команда Rust рада сообщить о новой версии языка — 1.63.0. Rust — это язык программирования, позволяющий каждому создавать надёжное и эффективное программное обеспечение.

Если у вас есть предыдущая версия Rust, установленная через `rustup`, то для обновления до версии 1.63.0 вам достаточно выполнить команду:

```console
rustup update stable
```

Если у вас ещё нет `rustup`, то можете установить его со [страницы](https://www.rust-lang.org/install.html) на нашем веб-сайте, а также ознакомиться с [подробным описанием выпуска 1.63.0](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1620-2022-06-30) на GitHub.

Если вы хотите помочь нам протестировать будущие выпуски, вы можете использовать beta (`rustup default beta`) или nightly (`rustup default nightly`) канал. Пожалуйста, [сообщайте](https://github.com/rust-lang/rust/issues/new/choose) обо всех встреченных вами ошибках.

## Что стабилизировано в 1.63.0

### Scoped threads

Rust code could launch new threads with `std::thread::spawn` since 1.0, but this function bounds its closure with `'static`. Roughly, this means that threads currently must have ownership of any arguments passed into their closure; you can't pass borrowed data into a thread. In cases where the threads are expected to exit by the end of the function (by being `join()`'d), this isn't strictly necessary and can require workarounds like placing the data in an [`Arc`](https://doc.rust-lang.org/stable/std/sync/struct.Arc.html).

Now, with 1.63.0, the standard library is adding *scoped* threads, which allow spawning a thread borrowing from the local stack frame. The [`std::thread::scope`](https://doc.rust-lang.org/stable/std/thread/fn.scope.html) API provides the necessary guarantee that any spawned threads will have exited prior to itself returning, which allows for safely borrowing data. Here's an example:

```rust
let mut a = vec![1, 2, 3];
let mut x = 0;

std::thread::scope(|s| {
    s.spawn(|| {
        println!("hello from the first scoped thread");
        // We can borrow `a` here.
        dbg!(&a);
    });
    s.spawn(|| {
        println!("hello from the second scoped thread");
        // We can even mutably borrow `x` here,
        // because no other threads are using it.
        x += a[0] + a[2];
    });
    println!("hello from the main thread");
});

// After the scope, we can modify and access our variables again:
a.push(4);
assert_eq!(x, a.len());
```

### Владение для сырых файловых дескрипторов (I/O безопасность)

Previously, Rust code working with platform APIs taking raw file descriptors (on unix-style platforms) or handles (on Windows) would typically work directly with a platform-specific representation of the descriptor (for example, a `c_int`, or the alias `RawFd`). For Rust bindings to such native APIs, the type system then failed to encode whether the API would take ownership of the file descriptor (e.g., `close`) or merely borrow it (e.g., `dup`).

Now, Rust provides wrapper types such as [`BorrowedFd`](https://doc.rust-lang.org/stable/std/os/unix/io/struct.BorrowedFd.html) and [`OwnedFd`](https://doc.rust-lang.org/stable/std/os/unix/io/struct.OwnedFd.html), which are marked as `#[repr(transparent)]`, meaning that `extern "C"` bindings can directly take these types to encode the ownership semantics. See the stabilized APIs section for the full list of wrapper types stabilized in 1.63, currently, they are available on cfg(unix) platforms, Windows, and WASI.

We recommend that new APIs use these types instead of the previous type aliases (like [`RawFd`](https://doc.rust-lang.org/stable/std/os/unix/io/type.RawFd.html)).

### `::&lt;&gt;` для обобщений в функциях с `impl Trait`

Нотация `::<>` может быть использована для уточнения типа параметра (`fn foo<T: Copy>`) даже когда типом аргумента указан `impl Trait`. Но указание типа для аргумента `impl Trait` через эту нотацию по-прежнему невозможно.

### Завершение миграции нелексических времён жизни

Как описывалось [в этом посте](https://blog.rust-lang.org/2022/08/05/nll-by-default.html), мы полностью удалили предыдущий лексический анализатор заимствований из rustc для всех редакций, а новый нелексический анализатор заимствований стал работать в полную силу. Теперь анализатор заимствований не воздействует на вывод rustc. Это не меняет поведения программ, но завершает длительную миграцию, начавшуюся со стабилизации NLL в 2018 редакции, которая привносит все преимущества нового анализатора заимствований во все редакции Rust. Для большинства пользователей это изменение будет выглядеть как слегка улучшенная диагностика некоторых ошибок заимствований, но это не повлияет на то, какой код они могут писать.

Узнать больше про нелексические времена жизни вы можете [в этом разделе анонса 2018 редакции](https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#non-lexical-lifetimes).

### Стабилизированные API

Стабилизированы следующие методы и реализации трейтов:

- [`array::from_fn`](https://doc.rust-lang.org/stable/std/array/fn.from_fn.html)
- [`Box::into_pin`](https://doc.rust-lang.org/stable/std/boxed/struct.Box.html#method.into_pin)
- [`BinaryHeap::try_reserve`](https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html#method.try_reserve)
- [`BinaryHeap::try_reserve_exact`](https://doc.rust-lang.org/stable/alloc/collections/binary_heap/struct.BinaryHeap.html#method.try_reserve_exact)
- [`OsString::try_reserve`](https://doc.rust-lang.org/stable/std/ffi/struct.OsString.html#method.try_reserve)
- [`OsString::try_reserve_exact`](https://doc.rust-lang.org/stable/std/ffi/struct.OsString.html#method.try_reserve_exact)
- [`PathBuf::try_reserve`](https://doc.rust-lang.org/stable/std/path/struct.PathBuf.html#method.try_reserve)
- [`PathBuf::try_reserve_exact`](https://doc.rust-lang.org/stable/std/path/struct.PathBuf.html#method.try_reserve_exact)
- [`Path::try_exists`](https://doc.rust-lang.org/stable/std/path/struct.Path.html#method.try_exists)
- [`Ref::filter_map`](https://doc.rust-lang.org/stable/std/cell/struct.Ref.html#method.filter_map)
- [`RefMut::filter_map`](https://doc.rust-lang.org/stable/std/cell/struct.RefMut.html#method.filter_map)
- [`NonNull::<[T]>::len`](https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.len)
- [`ToOwned::clone_into`](https://doc.rust-lang.org/stable/std/borrow/trait.ToOwned.html#method.clone_into)
- [`Ipv6Addr::to_ipv4_mapped`](https://doc.rust-lang.org/stable/std/net/struct.Ipv6Addr.html#method.to_ipv4_mapped)
- [`unix::io::AsFd`](https://doc.rust-lang.org/stable/std/os/unix/io/trait.AsFd.html)
- [`unix::io::BorrowedFd<'fd>`](https://doc.rust-lang.org/stable/std/os/unix/io/struct.BorrowedFd.html)
- [`unix::io::OwnedFd`](https://doc.rust-lang.org/stable/std/os/unix/io/struct.OwnedFd.html)
- [`windows::io::AsHandle`](https://doc.rust-lang.org/stable/std/os/windows/io/trait.AsHandle.html)
- [`windows::io::BorrowedHandle<'handle>`](https://doc.rust-lang.org/stable/std/os/windows/io/struct.BorrowedHandle.html)
- [`windows::io::OwnedHandle`](https://doc.rust-lang.org/stable/std/os/windows/io/struct.OwnedHandle.html)
- [`windows::io::HandleOrInvalid`](https://doc.rust-lang.org/stable/std/os/windows/io/struct.HandleOrInvalid.html)
- [`windows::io::HandleOrNull`](https://doc.rust-lang.org/stable/std/os/windows/io/struct.HandleOrNull.html)
- [`windows::io::InvalidHandleError`](https://doc.rust-lang.org/stable/std/os/windows/io/struct.InvalidHandleError.html)
- [`windows::io::NullHandleError`](https://doc.rust-lang.org/stable/std/os/windows/io/struct.NullHandleError.html)
- [`windows::io::AsSocket`](https://doc.rust-lang.org/stable/std/os/windows/io/trait.AsSocket.html)
- [`windows::io::BorrowedSocket<'handle>`](https://doc.rust-lang.org/stable/std/os/windows/io/struct.BorrowedSocket.html)
- [`windows::io::OwnedSocket`](https://doc.rust-lang.org/stable/std/os/windows/io/struct.OwnedSocket.html)
- [`thread::scope`](https://doc.rust-lang.org/stable/std/thread/fn.scope.html)
- [`thread::Scope`](https://doc.rust-lang.org/stable/std/thread/fn.scope.html)
- [`thread::ScopedJoinHandle`](https://doc.rust-lang.org/stable/std/thread/struct.ScopedJoinHandle.html)

Следующие API теперь возможно использовать в <code>const</code> контексте:

- [`array::from_ref`](https://doc.rust-lang.org/stable/std/array/fn.from_ref.html)
- [`slice::from_ref`](https://doc.rust-lang.org/stable/std/slice/fn.from_ref.html)
- [`intrinsics::copy`](https://doc.rust-lang.org/stable/std/intrinsics/fn.copy.html)
- [`intrinsics::copy_nonoverlapping`](https://doc.rust-lang.org/stable/std/intrinsics/fn.copy_nonoverlapping.html)
- [`<*const T>::copy_to`](https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_to)
- [`<*const T>::copy_to_nonoverlapping`](https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_to_nonoverlapping)
- [`<*mut T>::copy_to`](https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_to-1)
- [`<*mut T>::copy_to_nonoverlapping`](https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_to_nonoverlapping-1)
- [`<*mut T>::copy_from`](https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_from)
- [`<*mut T>::copy_from_nonoverlapping`](https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_from_nonoverlapping)
- [`str::from_utf8`](https://doc.rust-lang.org/stable/std/str/fn.from_utf8.html)
- [`Utf8Error::error_len`](https://doc.rust-lang.org/stable/std/str/struct.Utf8Error.html#method.error_len)
- [`Utf8Error::valid_up_to`](https://doc.rust-lang.org/stable/std/str/struct.Utf8Error.html#method.valid_up_to)
- [`Condvar::new`](https://doc.rust-lang.org/stable/std/sync/struct.Condvar.html#method.new)
- [`Mutex::new`](https://doc.rust-lang.org/stable/std/sync/struct.Mutex.html#method.new)
- [`RwLock::new`](https://doc.rust-lang.org/stable/std/sync/struct.RwLock.html#method.new)

### Прочие изменения

[Синтаксис](https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1630-2022-08-11), [пакетный менеджер Cargo](https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-163-2022-08-11) и [анализатор Clippy](https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-163) также претерпели некоторые изменения.

### Участники 1.63.0

Многие люди собрались вместе, чтобы создать Rust 1.63.0. Без вас мы бы не справились. [Спасибо!](https://thanks.rust-lang.org/rust/1.63.0/)
