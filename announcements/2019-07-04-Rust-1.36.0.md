Команда Rust рада сообщить о выходе новой версии Rust, 1.36.0.
Rust это язык программирования наделяющий любого __суперспособностью__ писать надёжное и эффективное программное обеспечение.

Если у Вас установлена предыдущая вресия Rust через rustup, то что бы обновиться до версии Rust 1.36.0 выполните:

```console
$ rustup update stable
```

Если `rustup` ещё у Вас не установлен, то сделать это Вы [можете][install] следуя инструкциям на соответствующей странице на нашем сайте,
а ознакомиться с [детальными релиз-ноутами к версии 1.36.0][notes] на Github.

[install]: https://www.rust-lang.org/install.html
[notes]: https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1360-2019-07-04

## Что нового в 1.36.0 stable

Этот релиз принёс много изменений,  включая стабилизацию типажа [`Future`],
[`alloc`][alloc-crate] крейта, типа [`MaybeUninit<T>`], [NLL для Rust 2015][felix-blog],
новой реализации `HashMap<K, V>` и поддержку [`--offline`] в Cargo.
Ниже приведены некоторые highlights, за дополнительной инвормацией можете обратиться к [детальным релиз-ноутам][notes].

### The [`Future`] is here!

[`Future`]: https://doc.rust-lang.org/std/future/trait.Future.html
[pr-future]: https://github.com/rust-lang/rust/pull/59739

В Rust 1.36.0 [стабилизирован][pr-future] долгожданный типаж [`Future`]!

Со стабилизацией, мы рнадеемся дать важным крейтам, библиотекам и экосистеме время подготовиться к `async` / `.await`,
о которых мы раскажем подробнее в будущем.

### Стабилизирован крейт [`alloc`][alloc-crate]

[alloc-crate]: https://doc.rust-lang.org/alloc/index.html

До версии 1.36.0, стандартная библиотека состояла из крейтов `std`, `core` и `proc_macro`.
В `core` крейте находилась базовая функциональность, такая как тпажи `Iterator` и `Copy`, и он
и мог быть использован в `#![no_std]` окружении, т.к. не предъявлял к нему ни каких требований.
В тоже время, `std` крейт предоставлял такие типы как `Box<T>` и OS-специфичную функциональность,
но взамен требовал наличия глобального аллокатора и __других OS-специфичных возможностей__.

Начиная с Rust 1.36.0, части `std` которые зависях от глобального аллокатора, например `Vec<T>`,
располагаются в `alloc` крейте. А `std` крейт реэкспортирует их.

Программы `#![no_std]` использующие `alloc` всё ещё требуют найтли Rust,
`#![no_std]` библиотеки могут использовать `alloc` крейт в стабильной версии Rust.
Втоже время, обычные программы, не `#![no_std]`, могу иметь такие библиотеки с списке своих зависимостей.
Мы надеемя что это поможет разработке экосистемы библиотек поддерживающих  `#![no_std]`
до стабилизации `#![no_std]` программ использущих `alloc`.


If you are the maintainer of a library that only relies on some allocation primitives to function,
consider making your library `#[no_std]` compatible by using the following at the top of your `lib.rs` file:

Если вы __поддерживаете/сопровождаете/майнтейнер__ библиотеки для работы которой нужны __некоторые (в смысле не много)__ примитивы аллокации памяти,
подумайте на тем, что бы сделать вашу библиотку совместимой с `#[no_std]` добавив в начало вашего `lib.rs` файла:

```rust
#![no_std]

extern crate alloc;

use alloc::vec::Vec;
```

### [`MaybeUninit<T>`] instead of [`mem::uninitialized`]

[`MaybeUninit<T>`]: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html
[`mem::uninitialized`]: https://doc.rust-lang.org/std/mem/fn.uninitialized.html
[gankro-blog]: https://gankro.github.io/blah/initialize-me-maybe/
[pr-60445]: https://github.com/rust-lang/rust/pull/60445

__В предыдущем релизе Rust, функция [`mem::uninitialized`] позволяла Вам обходить проверки Rust претворяясь
что вы инициализировали значение типа `T` не делая ничего.__
Зачастую эта функция применялась для ленивой инициализации массивов.

Однако, [`mem::uninitialized`] не вообразимо опасная операция, которая __essentially__ не может быть
использована корректно, так как компилятор Rust ожидает, что все значения инициализированны.

Например, вызов `mem::uninitialized::<bool>()` моментально приводит *__неопределённому поведению__*
, так как с точки зрения Rust, не инициализированные биты не являются ни `0` (для `false`)
ни `1` (для `true`) -- двух единственно допустимых битовых последовательностй для значей типа `bool`.

Что бы исправить эту ситуацию, в Rust 1.36.0, был [стабилизирован][pr-60445] тип [`MaybeUninit<T>`].
Компилятор Rust поймёт, что он не должен делать ни каких предположений о том, что [`MaybeUninit<T>`] содержит корректно
инициализированное значение тпа `T`.

И тем самым, вы можете более безопасно выполнять постепенную инициализацию, и по окончании которой, когда вы точно уверен
в том что, `maybe_t: MaybeUninit<T>` содержит правильно инициализированные значение `T`, вызвать `.assume_init()`.

Фнкция [`mem::uninitialized`] будет __удалена/помечена как устаревшая (она ж уже помечена как устаревшая)__,
так как теперь есть безопасная альтернатива - [`MaybeUninit<T>`] is the safer alternative, starting with Rust 1.38,
the function [`mem::uninitialized`] will be deprecated.

[`MaybeUninit<T>`], будучи безопасной альтернативой, заменит фнкцию [`mem::uninitialized`]. Последняя же начиная с версии Rust 1.38 будет помечена как устаревшая.

__В [Alexis Beingessner's блог-записи][gankro-blog] вы можете прочесть больше об не инициализированной памяти, [`mem::uninitialized`], типе [`MaybeUninit<T>`], read .__
Стандартная библиотека также содежит обширую документацию по [`MaybeUninit<T>`].

### NLL for Rust 2015

[nll-2018]: https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#non-lexical-lifetimes
[soundness]: https://en.wikipedia.org/wiki/Soundness
[felix-blog]: http://blog.pnkfx.org/blog/2019/06/26/breaking-news-non-lexical-lifetimes-arrives-for-everyone/
[crater-nll]: https://github.com/rust-lang/rust/issues/60680#issuecomment-495089654

[В анонсе к Rust 1.31.0][nll-2018], мы рассказывали о NLL (Non-Lexical Lifetimes),
улучшении языка, делающего бороучекер умнее и дружественнее к пользователю.
Например, теперь вы можете написать:

```rust
fn main() {
    let mut x = 5;
    let y = &x;
    let z = &mut x; // This was not allowed before 1.31.0.
}
```

В 1.31.0 NLL была стабилизирована только для Rust 2018,
но с обещанием бэкпортировать фитчу в Rust 2015.
И вот, с выходом Rust 1.36.0, мы рады сообщить, что мы это сделали! NLL теперь доступна и в Rust 2015.


Имея NLL в обеех редакциях, мы подходим ещё ближе к тому, что бы удалить старую реализацию Бороучекера.

Однако, старый Бороучекер, к сожалению, 

However, the old borrow checker unfortunately accepted some [unsound][soundness] code it should not have.

В результате, NLL 
As a result, NLL is currently in a "migration mode" wherein we will emit warnings instead
of errors if the NLL borrow checker rejects code the old AST borrow checker would accept.


Please see [this list][crater-nll] of public crates that are affected.


To find out more about NLL, MIR, the story around fixing soundness holes,
and what you can do about the warnings if you have them, read [Felix Klock's blog post][felix-blog].

### A new [`HashMap<K, V>`] implementation

[`hashbrown`]: https://crates.io/crates/hashbrown
[`HashMap<K, V>`]: https://doc.rust-lang.org/std/collections/struct.HashMap.html
[pr-hashbrown]: https://github.com/rust-lang/rust/pull/58623
[SwissTable]: https://abseil.io/blog/20180927-swisstables
[pr-hashbrown-perf]: https://perf.rust-lang.org/compare.html?start=b57fe74a27590289fd657614b8ad1f3eac8a7ad2&end=abade53a649583e40ed07c26ee10652703f09b58&stat=wall-time

В Rust 1.36.0, реализация `HashMap<K, V>` была [заменена][pr-hashbrown]
на реализацию из [`hashbrown`] крейта, которая основана на [SwissTable] design.
While the interface is the same, the `HashMap<K, V>` implementation is now
[faster on average][pr-hashbrown-perf] and has lower memory overhead.
Note that unlike the `hashbrown` crate,
the implementation in `std` still defaults to the SipHash 1-3 hashing algorithm.

### [`--offline`] support in Cargo

[`--offline`]: https://doc.rust-lang.org/cargo/commands/cargo-build.html#cargo_build_manifest_options
[`cargo fetch`]: https://doc.rust-lang.org/cargo/commands/cargo-fetch.html
[nrc-blog]: https://www.ncameron.org/blog/cargo-offline/
[relnotes-cargo]: https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-136-2019-07-04

Во время большинства сборок, Cargo не взаимодействует с сетью.

Иногда, онако, Cargo это требуется.
Например если добавляется зависимость и нужно скачать последнуюю совместимую версию.

__At times, network access is not an option though, for example on an airplane or in isolated build environments.__

В Rust 1.36, был стабилизирован новых флаг Cargo: [`--offline`].
Этот флаг меняет алгоритм разрешения зависимотей Cargo так, что бы использовилить только зависимости находящиеся в локальном кэше. Cargo завершит исполненеие с ошибкой, если требуемого крэйта нет в кэше, и для его получения нужен доступ к сети.

Вы можете выполнить команду [`cargo fetch`], что бы подготовить локальных кэш к тому, что скоро вы уйдёте в оффлайн.
Эта команда скачате все необходимые в проекте зависимости.

Вы можете узнаить больше об [`--offline`] и [`cargo fetch`] из [блог-поста Nick Cameron][nrc-blog].

Об остальных ихменениях в Cargo вы можете прочесть в [детальных релиз-ноутах][relnotes-cargo].

### Изменения в стандартной библиотеке

[`dbg!`]: https://doc.rust-lang.org/std/macro.dbg.html

В макрос [`dbg!`] можно передавать несколько аргументов.

Дополнительно, несколько API были сделаны `const`:

[`Layout::from_size_align_unchecked`]: https://doc.rust-lang.org/core/alloc/struct.Layout.html#method.from_size_align_unchecked
[`mem::needs_drop`]: https://doc.rust-lang.org/std/mem/fn.needs_drop.html
[`NonNull::dangling`]: https://doc.rust-lang.org/std/ptr/struct.NonNull.html#method.dangling
[`NonNull::cast`]: https://doc.rust-lang.org/std/ptr/struct.NonNull.html#method.cast

- [`Layout::from_size_align_unchecked`]
- [`mem::needs_drop`]
- [`NonNull::dangling`]
- [`NonNull::cast`]

Стабилизировано API, включая:

[`Iterator::copied`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.copied
[`VecDeque::rotate_left`]: https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.rotate_left
[`VecDeque::rotate_right`]: https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.rotate_right
[`BorrowMut<str> for String`]: https://github.com/rust-lang/rust/pull/60404
[`str::as_mut_ptr`]: https://doc.rust-lang.org/std/primitive.str.html#method.as_mut_ptr
[`pointer::align_offset`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.align_offset
[`Read::read_vectored`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_vectored
[`Write::write_vectored`]: https://doc.rust-lang.org/std/io/trait.Write.html#method.write_vectored
[`task::Waker`]: https://doc.rust-lang.org/std/task/struct.Waker.html
[`task::Poll`]: https://doc.rust-lang.org/std/task/enum.Poll.html

- [`task::Waker`] и [`task::Poll`]
- [`VecDeque::rotate_left`] and [`VecDeque::rotate_right`]
- [`Read::read_vectored`] and [`Write::write_vectored`]
- [`Iterator::copied`]
- [`BorrowMut<str> for String`]
- [`str::as_mut_ptr`]

Сведения о других изменениях в стандартной библиотеке доступны в [детальных релиз-ноутах][notes].

### Прочие изменения

[relnotes-clippy]: https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-136

Детальные релиз-ноуты к версии 1.36.0 доступны для [Rust][notes],
[Cargo][relnotes-cargo] и [Clippy][relnotes-clippy].

## Контрибьюторы в 1.36.0

Огромное число людей приложило свои усилия к созданию Rust 1.36.0. Без всех вас мы не смогли бы
этого сделать . [Спасибо!](https://thanks.rust-lang.org/rust/1.36.0/)
