Команда Rust рада сообщить о выходе новой версии Rust, 1.36.0.
Rust это язык программирования наделяющий любого способностью писать надёжное и эффективное программное обеспечение.

Если у Вас установлена предыдущая вресия Rust через rustup, то что бы обновиться до версии Rust 1.36.0 выполните:

```console
$ rustup update stable
```

Если `rustup` ещё у Вас не установлен, то сделать это Вы [можете][install] следуя инструкциям на соответствующей странице на нашем сайте,
а ознакомиться с [детальными релиз-ноутами к версии 1.36.0][notes] на Github.

[install]: https://www.rust-lang.org/install.html
[notes]: https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1360-2019-07-04

## Что нового в 1.36.0 stable

Этот релиз принёс много изменений,  включая стабилизацию типажа [`Future`],
[`alloc`][alloc-crate] крэйта, типа [`MaybeUninit<T>`], [NLL для Rust 2015][felix-blog],
новой реализации `HashMap<K, V>` и поддержку [`--offline`] в Cargo.
Далее мы кратко освятим основные изменения в этой версии, а за дополнительной инвормацией можете обратиться к [детальным релиз-ноутам][notes].

### Будущее ([`Future`]) уже здес!

[`Future`]: https://doc.rust-lang.org/std/future/trait.Future.html
[pr-future]: https://github.com/rust-lang/rust/pull/59739

В Rust 1.36.0 [стабилизирован][pr-future] долгожданный типаж [`Future`]!
С его стабилизацией, мы надеемся дать важным крэйтам, библиотекам и экосистеме время подготовиться к `async` / `.await`,
о которых мы раскажем подробнее в будущем.

### Стабилизирован крэйт [`alloc`][alloc-crate]

[alloc-crate]: https://doc.rust-lang.org/alloc/index.html

До версии 1.36.0, стандартная библиотека состояла из крэйтов `std`, `core` и `proc_macro`.
В `core` крэйте находилась базовая функциональность, такая как типажи `Iterator` и `Copy`, и он
и мог быть использован в `#![no_std]` окружении, т.к. не предъявлял к нему ни каких требований.
В тоже время, `std` крэйт предоставлял такие типы как `Box<T>` и OS-специфичную функциональность,
но взамен требовал наличия глобального аллокатора и других OS-специфичных функций.

Начиная с Rust 1.36.0, те чести `std`, которые зависят от глобального аллокатора, например `Vec<T>`,
располагаются в `alloc` крэйте. А `std` крейт реэкспортирует их.

Бинарные исполняемые файлы, программы, `#![no_std]` использующие `alloc` всё ещё требуют ночных выпусков Rust,
`#![no_std]` библиотеки же могут использовать `alloc` крэйт и в стабильной версии Rust.
Втоже время, обычные программы, не `#![no_std]`, могу иметь такие библиотеки в списке своих зависимостей.
Мы надеемя что это поможет разработке экосистемы библиотек поддерживающих `#![no_std]`
до того как будет стабилизированна фитча `#![no_std]` для программ использущих `alloc`.

Если вы майнтейнер библиотеки для работы которой нужны некоторые примитивы аллокации,
подумайте на тем, что бы сделать вашу библиотку совместимой с `#[no_std]` добавив в начало вашего `lib.rs` файла:

```rust
#![no_std]

extern crate alloc;

use alloc::vec::Vec;
```

### [`MaybeUninit<T>`] вместо [`mem::uninitialized`]

[`MaybeUninit<T>`]: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html
[`mem::uninitialized`]: https://doc.rust-lang.org/std/mem/fn.uninitialized.html
[gankro-blog]: https://gankro.github.io/blah/initialize-me-maybe/
[pr-60445]: https://github.com/rust-lang/rust/pull/60445

В предыдущих версиях Rust, функция [`mem::uninitialized`] позволяла Вам обходить проверки инициализации переменных.
Можно было претвориться, что вы инициализировали значение типа `T` ничего при этом не делая на самом деле.
Зачастую эта функция применялась для ленивой инициализации массивов.

Однако, [`mem::uninitialized`] не вообразимо опасная операция, которая, в принципе, не может быть
использована корректно, так как компилятор Rust ожидает, что все значения правильно инициализированны.

Например, вызов `mem::uninitialized::<bool>()` моментально приводит *__неопределённому поведению__*,
так как с точки зрения Rust, не инициализированные биты не являются ни `0` (в случае `false`)
ни `1` (для `true`) -- двух единственно допустимых битовых последовательностй для значей типа `bool`.

Что бы исправить эту ситуацию, в Rust 1.36.0, был [стабилизирован][pr-60445] тип [`MaybeUninit<T>`].
Компилятор Rust поймёт, что он не должен делать ни каких предположений о том, что [`MaybeUninit<T>`] содержит корректно
инициализированное значение тпа `T`.

И тем самым, вы можете более безопасно выполнять постепенную инициализацию переменных, и по окончании которой,
когда вы уже точно уверены в том что, `maybe_t: MaybeUninit<T>` содержит правильно инициализированные
значение `T`, вызвать `.assume_init()`.

Фнкция [`mem::uninitialized`] будет помечена как устаревшая начиная с Rust 1.38, так как теперь есть её безопасная альтернатива - [`MaybeUninit<T>`].

[`MaybeUninit<T>`], будучи безопасной альтернативой, заменит фнкцию [`mem::uninitialized`]. Последняя же начиная с версии Rust 1.38 будет помечена как устаревшая.

Больше информации об не инициализированной памяти, [`mem::uninitialized`] и типе [`MaybeUninit<T>`] Вы можете
прочтя [запис в блоге Alexis Beingessner][gankro-blog].
Стандартная библиотека также содежит обширую документацию по [`MaybeUninit<T>`].

### NLL для Rust 2015

[nll-2018]: https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#non-lexical-lifetimes
[soundness]: https://en.wikipedia.org/wiki/Soundness
[felix-blog]: http://blog.pnkfx.org/blog/2019/06/26/breaking-news-non-lexical-lifetimes-arrives-for-everyone/
[crater-nll]: https://github.com/rust-lang/rust/issues/60680#issuecomment-495089654

[В анонсе к Rust 1.31.0][nll-2018], мы рассказывали о NLL (Non-Lexical Lifetimes),
улучшении языка, делающего Бороучекер умнее и дружественнее к пользователю.
Например, теперь вы можете написать:

```rust
fn main() {
    let mut x = 5;
    let y = &x;
    let z = &mut x; // This was not allowed before 1.31.0.
}
```

В 1.31.0 NLL была стабилизирована только для Rust 2018,
но с обещанием бэкпортировать эту фитчу в Rust 2015.
И вот, с выходом Rust 1.36.0, мы рады сообщить, что мы это сделали! NLL теперь доступна и в Rust 2015.


Имея NLL в обеех редакциях, мы подходим ещё ближе к тому, что бы удалить старую реализацию Бороучекера.

Однако, старый Бороучекер, к сожалению, позволял писать некорректный код. По этому NLL
сейчас находиться в "режиме миграции", когда мы будем выдавать сообщения с предупреждениями вместо ошибок в тех местах,
в которых новый Бороучекер не может принять код, который принемала старая версия.

Список публично доступных крэйтов Вы можете найти [здесь][crater-nll].

Подробнее об NLL, MIR, об истории вокруг исправления дыр в непротиворичивости системы типов __(soundness holes)__,
и того, что можно сделать с предупреждениями если они у вас есть, читайте в [записи в блоге Flix Klock][felix-blog].

### Новая реализация [`HashMap<K, V>`]

[`hashbrown`]: https://crates.io/crates/hashbrown
[`HashMap<K, V>`]: https://doc.rust-lang.org/std/collections/struct.HashMap.html
[pr-hashbrown]: https://github.com/rust-lang/rust/pull/58623
[SwissTable]: https://abseil.io/blog/20180927-swisstables
[pr-hashbrown-perf]: https://perf.rust-lang.org/compare.html?start=b57fe74a27590289fd657614b8ad1f3eac8a7ad2&end=abade53a649583e40ed07c26ee10652703f09b58&stat=wall-time

В Rust 1.36.0, реализация `HashMap<K, V>` была [заменена][pr-hashbrown]
на реализацию из [`hashbrown`] крэйта, которая основана на проекте [SwissTable].

Сохранив свой интерфейс `HashMap<K, V>`, его реализация тепер стала
[в среднем быстрее][pr-hashbrown-perf] и имеет меньше накладных расходов по памяти.

Но заметьте, что в отличии от `hashbrown` крэйта, реализация из `std` всё ещё использует
SipHash 1-3 алгорит хеширования по умалчанию.

### Поддрежка [`--offline`] в Cargo

[`--offline`]: https://doc.rust-lang.org/cargo/commands/cargo-build.html#cargo_build_manifest_options
[`cargo fetch`]: https://doc.rust-lang.org/cargo/commands/cargo-fetch.html
[nrc-blog]: https://www.ncameron.org/blog/cargo-offline/
[relnotes-cargo]: https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-136-2019-07-04

Во время большинства сборок, Cargo не взаимодействует с сетью.

Иногда, онако, Cargo это требуется.
Например если добавляется зависимость и нужно скачать её последнуюю совместимую версию.

Но случается так, что доступ к сети --- не вариант, например когда Вы находитесь в самолёте или в ?__изолированном окружении для сборки__?.

В Rust 1.36, был стабилизирован новых флаг Cargo: [`--offline`].
Этот флаг меняет алгоритм разрешения зависимотей Cargo так, что бы использовилить только зависимости находящиеся в локальном кэше. Cargo завершит исполненеие с ошибкой, если требуемого крэйта нет в кэше, и для его получения нужен доступ к сети.

Вы можете выполнить команду [`cargo fetch`], что бы подготовить локальных кэш к тому, что скоро вы уйдёте в оффлайн.
Эта команда скачает все необходимые в проекте зависимости.

Вы можете узнаить больше об [`--offline`] и [`cargo fetch`] из [записи в блоге Nick Cameron][nrc-blog].

Об остальных ихменениях в Cargo вы можете прочесть в [детальных релиз-ноутах][relnotes-cargo].

### Изменения в стандартной библиотеке

[`dbg!`]: https://doc.rust-lang.org/std/macro.dbg.html

В макрос [`dbg!`] можно передавать несколько аргументов.

Несколько API были сделаны `const`:

[`Layout::from_size_align_unchecked`]: https://doc.rust-lang.org/core/alloc/struct.Layout.html#method.from_size_align_unchecked
[`mem::needs_drop`]: https://doc.rust-lang.org/std/mem/fn.needs_drop.html
[`NonNull::dangling`]: https://doc.rust-lang.org/std/ptr/struct.NonNull.html#method.dangling
[`NonNull::cast`]: https://doc.rust-lang.org/std/ptr/struct.NonNull.html#method.cast

- [`Layout::from_size_align_unchecked`]
- [`mem::needs_drop`]
- [`NonNull::dangling`]
- [`NonNull::cast`]

Стабилизировано API, включая:

[`Iterator::copied`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.copied
[`VecDeque::rotate_left`]: https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.rotate_left
[`VecDeque::rotate_right`]: https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.rotate_right
[`BorrowMut<str> for String`]: https://github.com/rust-lang/rust/pull/60404
[`str::as_mut_ptr`]: https://doc.rust-lang.org/std/primitive.str.html#method.as_mut_ptr
[`pointer::align_offset`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.align_offset
[`Read::read_vectored`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_vectored
[`Write::write_vectored`]: https://doc.rust-lang.org/std/io/trait.Write.html#method.write_vectored
[`task::Waker`]: https://doc.rust-lang.org/std/task/struct.Waker.html
[`task::Poll`]: https://doc.rust-lang.org/std/task/enum.Poll.html

- [`task::Waker`] и [`task::Poll`]
- [`VecDeque::rotate_left`] and [`VecDeque::rotate_right`]
- [`Read::read_vectored`] and [`Write::write_vectored`]
- [`Iterator::copied`]
- [`BorrowMut<str> for String`]
- [`str::as_mut_ptr`]

Сведения о других изменениях в стандартной библиотеке доступны в [детальных релиз-ноутах][notes].

### Прочие изменения

[relnotes-clippy]: https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-136

Детальные релиз-ноуты к версии 1.36.0 доступны для [Rust][notes],
[Cargo][relnotes-cargo] и [Clippy][relnotes-clippy].

## Контрибьюторы в 1.36.0

Огромное число людей приложило свои усилия к созданию Rust 1.36.0. Без всех вас мы не смогли бы
этого сделать . [Спасибо!](https://thanks.rust-lang.org/rust/1.36.0/)
